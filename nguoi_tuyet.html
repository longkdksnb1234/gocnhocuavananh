<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>X·∫øp Tuy·∫øt Noel - 5 Qu·∫£ Ch·ªët K√®o</title>
    <style>
        body {
            margin: 0;
            overflow: hidden; /* Ch·∫∑n cu·ªôn tuy·ªát ƒë·ªëi */
            background: linear-gradient(to bottom, #0f2027, #203a43, #2c5364);
            font-family: 'Arial', sans-serif;
            touch-action: none; /* Ch·∫∑n h√†nh ƒë·ªông m·∫∑c ƒë·ªãnh c·ªßa tr√¨nh duy·ªát */
            -webkit-user-select: none;
            user-select: none;
            position: fixed; /* C·ªë ƒë·ªãnh body ƒë·ªÉ kh√¥ng b·ªã n·∫£y tr√™n iOS */
            width: 100%;
            height: 100%;
        }
        canvas { display: block; }
        
        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            display: flex;
            gap: 15px;
        }

        .btn {
            width: 45px; 
            height: 45px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            color: white;
            font-weight: bold;
            font-size: 22px;
            border: 2px solid rgba(255,255,255,0.5);
            transition: background 0.2s;
            -webkit-tap-highlight-color: transparent; /* B·ªè highlight khi ch·∫°m */
        }

        .btn:active { background: rgba(255, 255, 255, 0.5); }
        
        #instruction {
            position: absolute;
            top: 20px;
            width: 100%;
            text-align: center;
            color: #bdc3c7;
            pointer-events: none;
            font-size: 16px;
            text-shadow: 0 1px 2px black;
            z-index: 90;
            font-weight: bold;
        }
    </style>
</head>
<body>

<div id="controls">
    <div class="btn" ontouchend="window.location.href='index.html'; event.preventDefault();" onclick="window.location.href='index.html'">üè†</div> 
    <div class="btn" ontouchend="location.reload(); event.preventDefault();" onclick="location.reload()">‚Ü∫</div> 
</div>

<div id="instruction">Ch·∫°m ƒë·ªÉ th·∫£ - 5 qu·∫£ l√† ch·ªët k√®o!</div>
<canvas id="gameCanvas"></canvas>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // --- KHO K√àO (GI·ªÆ NGUY√äN) ---
    const winBets = [
        { t: "5 QU·∫¢! ƒê·ªàNH CAO!", l1: "Long ph·∫£i bao ch·ªã ƒëi ƒÉn", l2: "Haidilao ngay l·∫≠p t·ª©c!" },
        { t: "TH·∫ÆNG R·ªíI!", l1: "Long t√¨nh nguy·ªán l√†m 'xe √¥m'", l2: "ƒë∆∞a ƒë√≥n ch·ªã c·∫£ tu·∫ßn t·ªõi!" },
        { t: "XU·∫§T S·∫ÆC!", l1: "Ch·ªã ƒë∆∞·ª£c quy·ªÅn y√™u c·∫ßu", l2: "Long l√†m b·∫•t c·ª© ƒëi·ªÅu g√¨ trong 24h!" },
        { t: "WINNER!", l1: "Long ph·∫£i mua t·∫∑ng ch·ªã", l2: "m·ªôt m√≥n qu√† Noel b√≠ m·∫≠t!" },
        { t: "QU√Å D·ªÆ!", l1: "Long ph·∫£i h√°t t·∫∑ng ch·ªã", l2: "m·ªôt b√†i t√¨nh ca tr∆∞·ªõc ƒë√°m ƒë√¥ng!" },
        { t: "CH·ªä TH·∫ÆNG!", l1: "Long ph·∫£i set avatar", l2: "h√¨nh ch·ªã ch·ªçn trong 3 ng√†y!" },
        { t: "GIRL BOSS!", l1: "Long ph·∫£i khen ch·ªã xinh", l2: "li√™n t·ª•c 50 l·∫ßn!" },
        { t: "K√àO TH∆†M!", l1: "Long bao tr·ªçn g√≥i", l2: "bu·ªïi ƒëi ch∆°i Noel n√†y!" },
        { t: "VIP PRO!", l1: "Long ph·∫£i c√µng ch·ªã", l2: "ƒëi d·∫°o ph·ªë ƒëi b·ªô!" },
        { t: "KH√îNG ƒê·ªêI TH·ª¶!", l1: "Long ph·∫£i l√†m video TikTok", l2: "m√∫a qu·∫°t t·∫∑ng ch·ªã!" },
        { t: "TH√ÅNH GAME!", l1: "Ch·ªã ch·ªçn ƒë·ªãa ƒëi·ªÉm,", l2: "Long lo ph·∫ßn thanh to√°n!" },
        { t: "HAY QU√Å!", l1: "Long ph·∫£i g·ª≠i ch·ªã 500k", l2: "ti·ªÅn ti√™u v·∫∑t l√¨ x√¨ s·ªõm!" },
        { t: "TUY·ªÜT V·ªúI!", l1: "Long ph·∫£i massage vai", l2: "cho ch·ªã 30 ph√∫t!" },
        { t: "10 ƒêI·ªÇM!", l1: "Long ph·∫£i g·ªçi ch·ªã l√†", l2: "'N·ªØ ho√†ng' trong 1 ng√†y!" }
    ];

    const loseBets = [
        { t: "TR∆Ø·ª¢T TAY R·ªíI!", l1: "Ch·ªã V√¢n Anh ph·∫£i m·ªùi Long", l2: "ƒëi ƒÉn kem m√πa ƒë√¥ng!" },
        { t: "TOANG R·ªíI!", l1: "Ch·ªã ph·∫£i h√°t t·∫∑ng Long", l2: "b√†i 'Jingle Bells' gi·ªçng v·ªãt!" },
        { t: "L·ªÜCH T√ÇM!", l1: "Ch·ªã V√¢n Anh ph·∫£i l√†m '√¥m'", l2: "cho Long ch·ªü ƒëi l∆∞·ª£n ph·ªë!" },
        { t: "NON QU√Å!", l1: "Ch·ªã ph·∫£i m·ªùi Long ƒëi", l2: "xem phim (Long ch·ªçn phim)!" },
        { t: "G√ÄI K√àO TH√ÄNH C√îNG!", l1: "Ch·ªã ph·∫£i set avatar ƒë√¥i", l2: "v·ªõi Long trong ƒë√™m Noel!" },
        { t: "THUA R·ªíI NHA!", l1: "Ch·ªã ph·∫£i ch√∫c Long ng·ªß ngon", l2: "b·∫±ng gi·ªçng ng·ªçt ng√†o nh·∫•t!" },
        { t: "R·ªöT ƒê√ÄI!", l1: "Ch·ªã ph·∫£i bao Long", l2: "m·ªôt ch·∫ßu tr√† s·ªØa full topping!" },
        { t: "GAME OVER!", l1: "Ch·ªã ph·∫£i khen Long ƒë·∫πp trai", l2: "c√¥ng khai tr√™n Facebook!" },
        { t: "H·ª§T R·ªíI!", l1: "Ch·ªã ph·∫£i n·∫Øm tay Long", l2: "ƒëi d·∫°o h·∫øt ƒë√™m Noel!" },
        { t: "XUI TH√îI!", l1: "Ch·ªã ph·∫£i ƒë·∫•m l∆∞ng cho Long", l2: "15 ph√∫t nha!" },
        { t: "PH·∫†T N·∫∂NG!", l1: "Ch·ªã ph·∫£i g·ª≠i Long 1 t·∫•m ·∫£nh", l2: "h·ªìi b√© si√™u ng·ªë t√†u!" },
        { t: "B·∫ÆT ƒê·ªÄN ƒê√ä!", l1: "Ch·ªã ph·∫£i l√†m g·ªëi √¥m", l2: "cho Long khi xem phim kinh d·ªã!" },
        { t: "THUA K√àO!", l1: "Ch·ªã ph·∫£i g·ªçi Long l√†", l2: "'Oppa' trong 24h!" },
        { t: "L·ªÜCH PHA!", l1: "Ch·ªã ph·∫£i mua t·∫∑ng Long", l2: "m·ªôt ƒë√¥i t·∫•t Noel cute!" },
        { t: "T·∫†CH R·ªíI!", l1: "Ch·ªã ph·∫£i ƒëi ƒÉn l·∫©u n∆∞·ªõng", l2: "v·ªõi Long ngay t·ªëi nay!" },
        { t: "Y·∫æU QU√Å!", l1: "Ch·ªã ph·∫£i thu √¢m b√†i h√°t", l2: "l√†m b√°o th·ª©c cho Long!" }
    ];

    // --- C·∫§U H√åNH ---
    let width, height;
    let balls = []; 
    let currentBall = null;
    let score = 0;
    let gameState = 'START'; 
    let cameraY = 0;
    let baseRadius; 
    let ropeLength; 
    let snowflakes = [];
    let trees = [];
    let anchorX = 0; 
    let activeBet = null; 
    let isHardMode = false;
    let isDragging = false;
    let startY = 0;
    let startCameraY = 0;
    let hasMoved = false;

    // Bi·∫øn m·ªõi ƒë·ªÉ fix l·ªói spam c·∫£m ·ª©ng
    let lastDropTime = 0; 
    const DROP_COOLDOWN = 300; // 300ms ngh·ªâ gi·ªØa c√°c l·∫ßn th·∫£

    // --- SETUP ---
    function resize() {
        width = canvas.width = window.innerWidth;
        height = canvas.height = window.innerHeight;
        baseRadius = Math.min(width, height) * 0.11; 
        ropeLength = height * 0.25; 
        
        // Fix: Ch·ªâ reset v·ªã tr√≠ n·∫øu ch∆∞a ch∆°i ho·∫∑c ƒëang start, tr√°nh reset khi thanh ƒë·ªãa ch·ªâ ·∫©n hi·ªán
        if(gameState === 'START') {
            anchorX = width / 2;
            initTrees(); // Ch·ªâ t·∫°o c√¢y l·∫°i khi m·ªõi v√†o
        }
        
        // Lu√¥n ƒë·∫£m b·∫£o c√≥ tuy·∫øt
        if(snowflakes.length === 0) initSnow();
        if(balls.length === 0) initGame();
    }
    
    // Fix: D√πng s·ª± ki·ªán resize th√¥ng minh h∆°n cho mobile
    let resizeTimeout;
    window.addEventListener('resize', () => {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(resize, 200);
    });

    function initSnow() {
        snowflakes = [];
        for(let i=0; i<120; i++) { 
            snowflakes.push({
                x: Math.random() * width, y: Math.random() * height,
                r: Math.random() * 2 + 1, d: Math.random() * 1 + 0.5 
            });
        }
    }

    function initTrees() {
        trees = [];
        let numTrees = Math.floor(width / 50);
        for(let i=0; i<numTrees; i++) {
            trees.push({
                x: Math.random() * width, y: height - 20,
                h: height * 0.1 + Math.random() * 50, 
                color: Math.random() > 0.5 ? '#145A32' : '#196F3D' 
            });
        }
    }

    function initGame() {
        balls = [];
        score = 0;
        cameraY = 0;
        anchorX = width / 2;
        isHardMode = Math.random() > 0.5;

        balls.push({
            x: width / 2,
            y: height - baseRadius - 20, 
            radius: baseRadius,
            funnyProps: null
        });
        spawnNextBall();
        gameState = 'PLAYING';
    }

    function spawnNextBall() {
        let minR = baseRadius * 0.75;
        let maxR = baseRadius * 0.95;
        let newRadius = Math.floor(Math.random() * (maxR - minR + 1)) + minR;
        
        let baseSpeed = 0.02 + (score * 0.002); 
        let finalSpeed = baseSpeed;
        let shiftRange = 0;
        
        if (isHardMode) {
            let trapChance = Math.random();
            if (trapChance < 0.35) finalSpeed = baseSpeed * 2.2;
            else if (trapChance < 0.5) finalSpeed = baseSpeed * 0.5;
            shiftRange = width * 0.35; 
        } else {
            let trapChance = Math.random();
            if (trapChance < 0.15) finalSpeed = baseSpeed * 1.3; 
            shiftRange = width * 0.15;
        }
        
        let shift = (Math.random() * shiftRange) - (shiftRange/2); 
        let prevBallX = balls[balls.length-1].x;
        let potentialAnchorX = (width / 2) + shift;
        let maxDist = ropeLength * Math.sin(0.8); 
        
        if (potentialAnchorX - prevBallX > maxDist) anchorX = prevBallX + maxDist;
        else if (prevBallX - potentialAnchorX > maxDist) anchorX = prevBallX - maxDist;
        else anchorX = potentialAnchorX;

        currentBall = {
            x: anchorX, y: 100, radius: newRadius,
            angle: 0, speed: finalSpeed, funnyProps: null
        };
    }

    function dropBall() {
        // Fix: Th√™m ki·ªÉm tra th·ªùi gian ƒë·ªÉ ch·ªëng spam click
        let now = Date.now();
        if (now - lastDropTime < DROP_COOLDOWN) return;
        lastDropTime = now;

        if (gameState !== 'PLAYING') return;

        let dropX = anchorX + Math.sin(currentBall.angle) * ropeLength;
        let prevBall = balls[balls.length - 1];

        let overlap = Math.min(prevBall.radius, currentBall.radius) * 0.3;
        let dropY = prevBall.y - prevBall.radius - currentBall.radius + overlap;

        let deltaX = Math.abs(dropX - prevBall.x);
        let limit = prevBall.radius; 

        if (deltaX > limit) { 
            gameOver();
        } else {
            balls.push({
                x: dropX, y: dropY, radius: currentBall.radius,
                funnyProps: null
            });
            score++;
            if (score >= 5) gameWin();
            else spawnNextBall();
        }
    }

    function gameOver() {
        gameState = 'GAMEOVER';
        activeBet = loseBets[Math.floor(Math.random() * loseBets.length)];
    }

    function gameWin() {
        gameState = 'GAMEWIN';
        activeBet = winBets[Math.floor(Math.random() * winBets.length)];
        balls.forEach(ball => {
            ball.funnyProps = {
                eyeType: Math.floor(Math.random() * 4),
                mouthType: Math.floor(Math.random() * 4),
                accessoryColor: `hsl(${Math.random() * 360}, 70%, 50%)`
            };
        });
    }

    // --- UPDATE ---
    function update() {
        for(let p of snowflakes) {
            p.y += p.d; p.x += Math.sin(p.y * 0.02) * 0.3;
            if(p.y > height) { p.y = -10; p.x = Math.random()*width; }
        }
        if (gameState === 'PLAYING' && currentBall) { // Check currentBall t·ªìn t·∫°i
            currentBall.angle += currentBall.speed;
            if (Math.abs(currentBall.angle) > 1.1) currentBall.speed *= -1;
            
            let topBall = balls[balls.length - 1];
            let targetY = 0;
            if (topBall.y - cameraY < height / 2) {
                targetY = (height / 2) - topBall.y + height*0.3;
            }
            cameraY += (targetY - cameraY) * 0.05;
        } 
    }

    function draw() {
        let bgGradient = ctx.createLinearGradient(0, 0, 0, height);
        bgGradient.addColorStop(0, "#0f2027"); bgGradient.addColorStop(1, "#2c5364");
        ctx.fillStyle = bgGradient; ctx.fillRect(0, 0, width, height);

        ctx.fillStyle = "rgba(255, 255, 255, 0.4)";
        ctx.beginPath();
        for(let p of snowflakes) { 
            if(p.r < 2) { ctx.moveTo(p.x, p.y); ctx.arc(p.x, p.y, p.r, 0, Math.PI*2, true); }
        }
        ctx.fill();

        ctx.save();
        ctx.translate(0, cameraY);

        ctx.fillStyle = "#fff"; ctx.fillRect(0, height - 30, width, 500); 
        for(let t of trees) drawTree(t.x, t.y, t.h, t.color);

        for (let i = 0; i < balls.length; i++) {
             drawPlainBall(balls[i]);
             if (gameState === 'GAMEWIN') drawFunnyDecor(balls[i]);
        }

        if (gameState === 'PLAYING' && currentBall) {
            let ballX = anchorX + Math.sin(currentBall.angle) * ropeLength;
            let prev = balls[balls.length-1];
            let overlap = Math.min(prev.radius, currentBall.radius) * 0.3;
            let displayY = (prev.y - prev.radius - currentBall.radius + overlap); 
            
            ctx.beginPath(); 
            let anchorY = displayY - ropeLength - height*0.2; 
            ctx.moveTo(anchorX, anchorY); 
            ctx.lineTo(ballX, displayY);
            ctx.strokeStyle = "rgba(255,255,255,0.3)"; ctx.lineWidth = 2; ctx.stroke();
            
            ctx.fillStyle="red"; ctx.beginPath(); ctx.arc(anchorX, anchorY, 5, 0, Math.PI*2); ctx.fill();

            drawPlainBall({x: ballX, y: displayY, radius: currentBall.radius});
        }
        ctx.restore();

        ctx.fillStyle = "rgba(255, 255, 255, 0.8)";
        ctx.beginPath();
        for(let p of snowflakes) { 
            if(p.r >= 2) { ctx.moveTo(p.x, p.y); ctx.arc(p.x, p.y, p.r, 0, Math.PI*2, true); }
        }
        ctx.fill();

        drawUI();
    }

    function drawTree(x, y, h, color) {
        ctx.fillStyle = "#5D4037"; ctx.fillRect(x - 3, y - 8, 6, 8); 
        ctx.fillStyle = color;
        for(let i=0; i<3; i++) { 
            ctx.beginPath();
            ctx.moveTo(x, y - 8 - h + (i*(h/2.8)));
            ctx.lineTo(x - 12 - (i*5), y - 8 - (i*(h/3.5)));
            ctx.lineTo(x + 12 + (i*5), y - 8 - (i*(h/3.5)));
            ctx.fill();
        }
    }

    function drawPlainBall(ball) {
        let grd = ctx.createRadialGradient(ball.x - ball.radius/3, ball.y - ball.radius/3, 5, ball.x, ball.y, ball.radius);
        grd.addColorStop(0, "#fff");
        grd.addColorStop(0.8, "#d7e1ec"); 
        grd.addColorStop(1, "#b0bec5");
        ctx.fillStyle = grd;
        ctx.beginPath(); ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2); ctx.fill();
    }

    function drawFunnyDecor(ball) {
        if (!ball.funnyProps) return;
        let p = ball.funnyProps;
        let r = ball.radius;
        // (Gi·ªØ nguy√™n logic v·∫Ω m·∫∑t c∆∞·ªùi...)
        if (p.eyeType === 0) { 
             drawEye(ball.x - r/3, ball.y - r/4, r/4, true); drawEye(ball.x + r/3, ball.y - r/4, r/4, true);
        } else if (p.eyeType === 1) { 
             ctx.strokeStyle = "#333"; ctx.lineWidth = 2;
             ctx.beginPath(); ctx.moveTo(ball.x - r/2, ball.y - r/4); ctx.lineTo(ball.x, ball.y - r/4); ctx.stroke();
             ctx.beginPath(); ctx.moveTo(ball.x + r/4, ball.y - r/4); ctx.lineTo(ball.x + r/2 + 5, ball.y - r/4); ctx.stroke();
        } else if (p.eyeType === 2) { 
             drawEye(ball.x - r/3, ball.y - r/4, r/3, false); drawEye(ball.x + r/3, ball.y - r/4, r/6, false);
        } else { 
             ctx.strokeStyle = "#333"; ctx.lineWidth = 2; drawX(ball.x - r/3, ball.y - r/4, r/5); drawX(ball.x + r/3, ball.y - r/4, r/5);
        }
        if (p.mouthType === 0) { 
             ctx.fillStyle = "#333"; ctx.beginPath(); ctx.arc(ball.x, ball.y + r/6, r/3, 0, Math.PI); ctx.fill();
             ctx.fillStyle = "red"; ctx.beginPath(); ctx.arc(ball.x, ball.y + r/3, r/6, 0, Math.PI); ctx.fill(); 
        } else if (p.mouthType === 1) { 
             ctx.fillStyle = "white"; ctx.strokeStyle="black"; ctx.lineWidth=1;
             ctx.fillRect(ball.x-r/4, ball.y+r/6, r/2, r/3); ctx.strokeRect(ball.x-r/4, ball.y+r/6, r/2, r/3);
             ctx.beginPath(); ctx.moveTo(ball.x, ball.y+r/6); ctx.lineTo(ball.x, ball.y+r/2); ctx.stroke();
        } else if (p.mouthType === 2) { 
             ctx.strokeStyle = "#333"; ctx.lineWidth = 2; ctx.beginPath();
             ctx.moveTo(ball.x - r/3, ball.y + r/4); ctx.lineTo(ball.x + r/3, ball.y + r/6); ctx.stroke();
        } else { 
             ctx.strokeStyle = "#333"; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(ball.x-r/4, ball.y+r/4); ctx.lineTo(ball.x+r/4, ball.y+r/4); ctx.stroke();
             ctx.fillStyle = "#81D4FA"; ctx.beginPath(); ctx.arc(ball.x+r/4, ball.y+r/2, r/10, 0, Math.PI*2); ctx.fill();
        }
    }
    function drawEye(x, y, size, googly) {
        ctx.fillStyle = "white"; ctx.strokeStyle = "black"; ctx.lineWidth = 1;
        ctx.beginPath(); ctx.arc(x, y, size, 0, Math.PI*2); ctx.fill(); ctx.stroke();
        let px = x, py = y;
        if(googly) { px += (Math.random()-0.5)*size/2; py += (Math.random()-0.5)*size/2; }
        ctx.fillStyle = "black"; ctx.beginPath(); ctx.arc(px, py, size/3, 0, Math.PI*2); ctx.fill();
    }
    function drawX(x, y, size) {
        ctx.beginPath(); ctx.moveTo(x-size, y-size); ctx.lineTo(x+size, y+size); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(x+size, y-size); ctx.lineTo(x-size, y+size); ctx.stroke();
    }

    function drawUI() {
        ctx.fillStyle = "white"; ctx.font = "bold 24px Arial"; ctx.textAlign = "right";
        ctx.shadowColor="black"; ctx.shadowBlur=4;
        ctx.fillText("ƒêi·ªÉm: " + score + "/5", width - 20, 40);
        ctx.shadowBlur=0;

        if (gameState === 'GAMEWIN' && activeBet) {
            drawTextNoBg("#27ae60", activeBet.t, activeBet.l1, activeBet.l2);
        }
        else if (gameState === 'GAMEOVER' && activeBet) {
             drawOverlay("#c0392b", activeBet.t, activeBet.l1, activeBet.l2);
        }
    }

    function drawTextNoBg(color, title, line1, line2) {
        ctx.textAlign = "center";
        let titleSize = Math.min(36, width * 0.08);
        let subSize = Math.min(24, width * 0.05);
        let noteSize = Math.min(16, width * 0.04);
        
        ctx.lineWidth = 4; ctx.strokeStyle = "black";
        ctx.font = `bold ${titleSize}px Arial`; ctx.strokeText(title, width/2, height/2 - 50);
        ctx.font = `bold ${subSize}px Arial`; 
        ctx.strokeText(line1, width/2, height/2 + 10);
        ctx.strokeText(line2, width/2, height/2 + 45);
        ctx.font = `${noteSize}px Arial`; ctx.strokeText("(Vu·ªët ƒë·ªÉ xem th√°p - Ch·∫°m ƒë·ªÉ ch∆°i l·∫°i)", width/2, height/2 + 100);

        ctx.fillStyle = color; ctx.font = `bold ${titleSize}px Arial`; ctx.fillText(title, width/2, height/2 - 50);
        ctx.fillStyle = "white"; ctx.font = `bold ${subSize}px Arial`; 
        ctx.fillText(line1, width/2, height/2 + 10);
        ctx.fillText(line2, width/2, height/2 + 45);
        ctx.fillStyle = "#bdc3c7"; ctx.font = `${noteSize}px Arial`; 
        ctx.fillText("(Vu·ªët ƒë·ªÉ xem th√°p - Ch·∫°m ƒë·ªÉ ch∆°i l·∫°i)", width/2, height/2 + 100);
    }

    function drawOverlay(color, title, line1, line2) {
        ctx.fillStyle = "rgba(0,0,0,0.6)"; ctx.fillRect(0,0,width,height);
        ctx.textAlign = "center";
        
        let titleSize = Math.min(36, width * 0.08);
        let subSize = Math.min(24, width * 0.05);
        let noteSize = Math.min(16, width * 0.04);
        
        ctx.fillStyle = color; ctx.font = `bold ${titleSize}px Arial`; ctx.fillText(title, width/2, height/2 - 50);
        ctx.fillStyle = "white"; ctx.font = `bold ${subSize}px Arial`; 
        ctx.fillText(line1, width/2, height/2 + 10);
        ctx.fillText(line2, width/2, height/2 + 45);
        ctx.fillStyle = "#bdc3c7"; ctx.font = `${noteSize}px Arial`; 
        ctx.fillText("(Vu·ªët ƒë·ªÉ xem th√°p - Ch·∫°m ƒë·ªÉ ch∆°i l·∫°i)", width/2, height/2 + 100);
    }

    function getClientY(e) { return e.touches ? e.touches[0].clientY : e.clientY; }

    function handleStart(e) {
        // Fix: Ch·∫∑n s·ª± ki·ªán n·ªïi b·ªçt
        if(e.target.closest('#controls')) return;
        
        // Fix: N·∫øu l√† touchstart, ch·∫∑n lu√¥n mouse event gi·∫£ l·∫≠p sau ƒë√≥
        if(e.type === 'touchstart') {
            e.preventDefault(); 
        }
        
        if (gameState === 'GAMEOVER' || gameState === 'GAMEWIN') {
            isDragging = true;
            startY = getClientY(e);
            startCameraY = cameraY;
            hasMoved = false;
        } else {
            dropBall();
        }
    }

    function handleMove(e) {
        if (isDragging) {
            let y = getClientY(e);
            let dy = y - startY;
            if (Math.abs(dy) > 5) hasMoved = true; 
            cameraY = startCameraY + dy;
            e.preventDefault(); 
        }
    }

    function handleEnd(e) {
        if (isDragging) {
            isDragging = false;
            // Fix: TƒÉng ng∆∞·ª°ng di chuy·ªÉn ƒë·ªÉ tr√°nh reset nh·∫ßm khi ch·∫°m nh·∫π
            if (!hasMoved) {
                 // Debounce cho n√∫t replay lu√¥n
                 let now = Date.now();
                 if (now - lastDropTime > DROP_COOLDOWN) {
                     lastDropTime = now;
                     initGame();
                 }
            }
        }
    }

    // Fix: G·∫Øn event listener chu·∫©n cho mobile
    canvas.addEventListener('mousedown', handleStart);
    canvas.addEventListener('mousemove', handleMove);
    canvas.addEventListener('mouseup', handleEnd);
    
    // Passive: false ƒë·ªÉ c√≥ th·ªÉ d√πng preventDefault() ch·∫∑n cu·ªôn trang
    canvas.addEventListener('touchstart', handleStart, {passive: false});
    canvas.addEventListener('touchmove', handleMove, {passive: false});
    canvas.addEventListener('touchend', handleEnd);
    
    resize();
    initTrees(); // ƒê·∫£m b·∫£o c√¢y c·ªëi c√≥ ngay t·ª´ ƒë·∫ßu
    function loop() { update(); draw(); requestAnimationFrame(loop); }
    loop();

</script>
</body>
</html>
